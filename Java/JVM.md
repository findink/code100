# JVM

## 内存区域

### Java运行时数据区域
1.8以前
![](images/Pasted%20image%2020230309142750.png)

1.8以后
![](images/Pasted%20image%2020230309142810.png)
**线程私有数据：**
-  程序计数器
-  虚拟机栈
-  本地方法栈

**线程共享的：**
-  堆
-  方法区
-  直接内存 (非运行时数据区的一部分)

#### 程序计数器
- 通过改变程序计数器来依次读取指令，从而实现代码的流程控制
- 上下文切换时，回复线程上次执行位置。

程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

#### Java 虚拟机栈
Java 虚拟机栈（后文简称栈）也是线程私有的，它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。
方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。
每个栈帧中都拥有：**局部变量表、操作数栈、动态链接、方法返回地址**。
局部变量表：各种**数据类型、对象引用变量**
操作数栈：用于存放方法执行过程中产生的**中间计算结果，临时变量**等。
动态链接：动态链接的作用就是为了**将符号引用转换为调用方法的直接引用**。
方法返回地址：一种是**return 语句正常返回，一种是抛出异常**。不管哪种返回方式，都会导致栈帧被弹出。**栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。**
![](images/Pasted%20image%2020230309144800.png)

栈可能会出现两种错误：
- StackOverFlowError：若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java虚拟机栈的最大深度的时候，就抛出 StackOverFlowError错误。
- OutOfMemoryError：如果栈的内存大小可以**动态扩展**，如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。

#### 本地方法栈
和虚拟机栈所发挥的作用非常相似，区别是：**虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务**。 在HotSpot虚拟机中将其和Java虚拟机栈合二为一。

该有的都有

#### 堆
Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。
目的：**唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

（逃逸分析：如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。）

堆也称GC堆，是垃圾收集器管理的主要区域。
细分为：新生代和老年代堆（按分代垃圾收集算法）
1.7以前
- 新生代
- 老生代
- 永久代
![](images/Pasted%20image%2020230309150308.png)

Eden区、两个Survivor区S0和S1都属于新生代，中间一层属于老年代，最下面一层属于永久代。

1.8及以后原空间取代永久代

> 大部分情况，对象都会首先在Eden区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入S0或者S1，并且对象的年龄还会加1(Eden区->Survivor区后对象的初始年龄变为1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold来设置。

堆这里最容易出现的就是OutOfMemoryError错误

#### 方法区
属于JVM运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。常量，字节码信息，静态变量等
方法区会存储已被虚拟机加载的**类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存**等数据。

![](images/Pasted%20image%2020230309153425.png)
**方法区和永久代以及元空间之间的关系**
永久代以及元空间是HotSpot虚拟机对虚拟机规范中方法区的两种**实现方式**，永久代是JDK1.8之前的方法区实现，JDK1.8及以后方法区的实现变成了元空间。

**元空间替代方法区**
- 整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，**而元空间使用的是直接内存**，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。
- 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了, 而**由系统的实际可用空间来控制**，这样能**加载的类就更多**了
- 在JDK8，合并HotSpot和JRockit的代码时, JRockit从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。

**方法区常用参数**
1.8之前
```c
-XX:PermSize=N //方法区 (永久代) 初始大小
-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen
```

1.8
元空间：
```c
-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）
-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小
```
与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。

#### 运行时常量池
Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种**字面量**（Literal）和**符号引用**（Symbolic Reference）的**常量池表(Constant Pool Table)** 。

字面量包括**整数、浮点数和字符串字面量**;
符号引用包括**类符号引用、字段符号引用、方法符号引用和接口方法符号引用**。

常量池表会在类加载后存放到方法区的运行时常量池中。

当常量池无法再申请到内存时会抛出OutOfMemoryError错误。

#### 字符串常量池
**字符串常量池** 是JVM为了提升性能和减少内存消耗针对字符串（String类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

JDK1.7之前，字符串常量池存放在永久代。JDK1.7**字符串常量池和静态变量从永久代移动了Java堆中**。
![](images/Pasted%20image%2020230309160014.png)
![](images/Pasted%20image%2020230309160021.png)
**为什么要将字符串常量池移动到堆中**
因为永久代（方法区实现）的GC回收效率太低，只有在整堆收集(Full GC)的时候才会被执行GC。Java程序中通常会有大量的被创建的字符串等待回收，**将字符串常量池放到堆中，能够更高效及时地回收字符串内存**。

> **运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念，是公共且抽象的，Metaspace、Heap 是与具体某种虚拟机实现相关的物理概念，是私有且具体的。**

#### 直接内存
直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致OutOfMemoryError错误出现。不受Java堆限制，但受本地内存大小限制。

> JDK1.4中新加入的NIO(New Input/Output)类，引入了一种基于通道（Channel）与缓存区（Buffer）的I/O方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在Java堆和Native堆之间来回复制数据。

### HotSpot 虚拟机对象探秘

#### 对象的创建
- 类加载检查：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。
- 分配内存：类加载完成后，JVM为对象在堆中分配一块确定大小的内存；**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。
- 初始化零值：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
- 设置对象头：包括属于哪个类的实例，如何找类的元数据信息，对象哈希码，对象GC分代等
- 执行init方法：最后一步执行init方法，使得Java程序创建完成对象

**内存分配的两种方式**
- 指针碰撞：
	- 适用场合：堆内存规整（即没有内存碎片）的情况下。
	- 原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。
	- 使用该分配方式的GC收集器：Serial, ParNew
- 空闲列表
	- 适用场合： 堆内存不规整的情况下。
	- 原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。
	- 使用该分配方式的GC收集器：CMS

**内存分配并发问题**
虚拟机采用两种方式来保证线程安全：
- CAS+失败重试： CAS 是乐观锁的一种实现方式。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
- **TLAB**：为每一个**线程**预先在Eden区分配的一块内存。JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配

#### 对象的内存布局
在Hotspot虚拟机中，对象在内存中的布局可以分为3块区域：**对象头**、**实例数据**和**对齐填充**。

**对象头包括两部分信息**，**第一部分用于存储对象自身的运行时数据，另一部分是类型指针**(mark word 和 class pointer)
![[images/Pasted image 20230411195411.png]]
mark word

**实例数据部分是对象真正存储的有效信息**
**对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用**（数据对齐）

#### 对象的访问定位
对象的访问方式由虚拟机实现而定，目前主流的访问方式有：**使用句柄**、**直接指针**。
**句柄**
Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。
![](images/Pasted%20image%2020230309162900.png)
**直接指针**
reference 中存储的直接就是对象的地址。
![](images/Pasted%20image%2020230309162913.png)

> 这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。

## JVM 垃圾回收
### 堆空间基本结构
Java的自动内存管理主要是**针对对象内存的回收和对象内存的分配**。同时，Java 自动内存管理最核心的功能是**堆**内存中对象的分配与回收。
Java堆是垃圾收集器管理的主要区域，因此也被称作**GC堆**（Garbage Collected Heap）。

由于现在收集器基本都采用**分代垃圾收集算法**，所以Java堆被划分为了几个不同的区域，这样我们就可以根据各个区域的特点选择合适的垃圾收集算法。

在JDK7版本及JDK7版本之前，堆内存被通常分为下面三部分：
1. 新生代内存(Young Generation)
2. 老生代(Old Generation)
3. 永久代(Permanent Generation)

新生代：eden区、survivor区的s1和s2（每次minor GC）
老年代：(每次full GC)
永久代：
![[images/Pasted image 20230325102559.png]]
**JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存** 。

### 内存分配和回收原则
#### 对象优先在 Eden 区分配
大多数情况下，对象在新生代中Eden区分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次**Minor GC**。

#### 大对象直接进入老年代
大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。
大对象直接进入老年代主要是为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。

#### 长期存活的对象将进入老年代
虚拟机采用了分代收集的思想来管理内存，内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。虚拟机给每个对象一个**对象年龄（Age）计数器**。

如果对象在 Eden 出生并经过**第一次MinorGC后仍然能够存活**，并且能被Survivor容纳的话，将被**移动到 Survivor空间（s0或者s1）中**，并将对象年龄设为1(Eden区到Survivor区后对象的初始年龄变为1)。
当它的年龄增加到一定程度（默认为15岁）就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 **-XX:MaxTenuringThreshold**来设置。

> 默认晋升年龄并不都是 15，这个是要区分垃圾收集器的，CMS就是6.

#### 主要进行 gc 的区域
针对 HotSpot VM 的实现，它里面的GC其实准确分类只有两大种：
- 部分收集 (Partial GC)：
	1. 新生代收集（Minor GC/Young GC）：只对新生代进行垃圾收集；
	2. 老年代收集（Major GC/Old GC）：只对老年代进行垃圾收集。需要注意的是Major GC在有的语境中也用于指代整堆收集；
	3. 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。
- 整堆收集(Full GC)：收集整个Java堆和方法区。

#### 空间分配担保
空间分配担保是为了确保在Minor GC之前**老年代本身还有容纳新生代所有对象的剩余空间**。（会把新生代中的存活对象移动老年代，但感觉不会全移动，只是为了保证能全部移动才要求剩余空间要大于新生代所有对象空间之和）

### 死亡对象判断方法
堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。

#### 引用计数法
给对象中添加一个引用计数器：
- 每当有一个地方引用它，计数器就加 1；
- 当引用失效，计数器就减 1；
- 任何时候计数器为 0 的对象就是不可能再被使用的。

这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它**很难解决对象之间相互循环引用的问题**。

#### 可达性分析算法
基本思想就是通过一系列的称为“**GC Roots**”的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当**一个对象到GC Roots没有任何引用链相连的话，则证明此对象是不可用的，需要被回收**。

**哪些对象可以作为 GC Roots**
- 虚拟机栈(栈帧中的本地变量表)中引用的对象
- 本地方法栈(Native方法)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁持有的对象

**对象可以被回收，就代表一定会被回收吗？**
即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“**缓刑阶段**”，要真正宣告一个对象死亡，**至少要经历两次标记过程**；可达性分析法中不可达的对象被**第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法**。当对象没有覆盖finalize方法，或finalize方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。被**判定为需要执行的对象将会被放在一个队列中进行第二次标记**，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。
> 没必要执行就可以直接回收？

#### 引用类型总结
JDK1.2之前，Java中引用的定义很传统：如果reference类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。
JDK1.2以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）

**强引用（StrongReference）**
大部分引用实际上都是强引用，这是使用最普遍的引用，垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。

**软引用（SoftReference）**
如果内存空间足够，垃圾回收器就不会回收它，如果**内存空间不足了，就会回收这些对象的内存**。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
软引用**可以**和一个**引用队列**（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。

**弱引用（WeakReference）**
弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，**一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存**。
弱引用**可以**和一个**引用队列**（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。

**虚引用**
如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。**虚引用主要用来跟踪对象被垃圾回收的活动**。

**虚引用与软引用和弱引用的一个区别在于**：虚引用必须和引用队列（ReferenceQueue）联合使用

> 在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为**软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**。

#### 如何判断一个常量是废弃常量？
运行时常量池主要回收的是废弃的常量。
假如在字符串常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池了。
**即没有任何对象引用该常量**

#### 如何判断一个类是无用的类
- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
- 加载该类的ClassLoader已经被回收。
- 该类对应的java.lang.Class对象没有在任何地方被引用，**无法在任何地方通过反射访问该类的方法**。
> 虚拟机可以对满足这些条件的类进行回收，但不一定必须回收

### 垃圾收集算法
#美团 
#### 标记-清除算法
该算法分为“标记”和“清除”阶段：首先**标记出所有不需要回收的对象**，在标记完成后**统一回收掉所有没有被标记的对象**。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。
缺点：
- **效率问题**
- **空间问题（标记清除后会产生大量不连续的碎片）**
![[images/Pasted image 20230325114731.png]]

#### 标记-复制算法
它可以将内存**分为大小相同的两块**，每次使用其中的一块。当**这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉**。这样就使每次的内存回收都是对内存区间的一半进行回收。
解决的效率问题
![[images/Pasted image 20230325114838.png]]

#### 标记-整理算法
根据**老年代**的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是**让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存**。

#### 分代收集算法
当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为**新生代和老年代**，这样我们就可以**根据各个年代的特点选择合适的垃圾收集算法**。

### 垃圾收集器
**根据具体应用场景选择适合自己的垃圾收集器**。
#### Serial 收集器
Serial（串行）收集器是最基本、历史最悠久的垃圾收集器。它是一个单线程收集器。**“单线程”** 意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，而且它在进行垃圾收集工作的时候必须**暂停其他所有的工作线程**（ **"Stop The World"** ），直到它收集结束。

**新生代采用标记-复制算法，老年代采用标记-整理算法。**

#### ParNew 收集器
**ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。**

**新生代采用标记-复制算法，老年代采用标记-整理算法。**
Server 模式下的虚拟机的首要选择

#### Parallel Scavenge 收集器
Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。
但它更关注CPU吞吐量，**所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值**。

**新生代采用标记-复制算法，老年代采用标记-整理算法**。

#### Serial Old 收集器
**Serial 收集器的老年代版本**，它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。

#### Parallel Old 收集器
**Parallel Scavenge 收集器的老年代版本**。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。

#### CMS 收集器
**CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用**。

**第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作**。

CMS 收集器是一种 **“标记-清除”算法**实现的，整个过程分为四个步骤。
- 初始标记：暂停所有的其他线程，并记录下直接与root相连的对象，速度很快；
- 并发标记：同时开启GC和用户线程，用一个**闭包结构**去记录可达对象。但在这个阶段结束，这个**闭包结构并不能保证包含当前所有的可达对象**。因为用户线程可能会不断的更新引用域，**GC 线程无法保证可达性分析的实时性**。这个算法里会跟踪记录这些发生引用更新的地方
- 重新标记：重新标记阶段就是为了**修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录**，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
- 并发清除：开启用户线程，同时GC线程开始对未标记的区域做清扫。
![[images/Pasted image 20230325120151.png]]
主要优点：**并发收集、低停顿**。
缺点：
- **对CPU资源敏感；**
- **无法处理浮动垃圾；**
- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生**

#### G1 收集器
**是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.**

## 类文件结构
### 字节码
JVM 可以理解的代码就叫做`字节码`（即扩展名为`.class`的文件），只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。

### Class 文件结构总结
```c
ClassFile {
    u4             magic; //Class 文件的标志
    u2             minor_version;//Class 的小版本号
    u2             major_version;//Class 的大版本号
    u2             constant_pool_count;//常量池的数量
    cp_info        constant_pool[constant_pool_count-1];//常量池
    u2             access_flags;//Class 的访问标记
    u2             this_class;//当前类
    u2             super_class;//父类
    u2             interfaces_count;//接口
    u2             interfaces[interfaces_count];//一个类可以实现多个接口
    u2             fields_count;//Class 文件的字段属性
    field_info     fields[fields_count];//一个类可以有多个字段
    u2             methods_count;//Class 文件的方法数量
    method_info    methods[methods_count];//一个类可以有个多个方法
    u2             attributes_count;//此类的属性表中的属性数
    attribute_info attributes[attributes_count];//属性表集合
}
```

Class文件通过`ClassFile`定义，有点类似 C 语言的结构体。

#### 魔数（Magic Number）
```c
    u4             magic; //Class 文件的标志
```
每个 Class 文件的**头4个字节**称为魔数（Magic Number）,它的唯一作用是**确定这个文件是否为一个能被虚拟机接收的 Class 文件**。

#### Class 文件版本号（Minor&Major Version）
```c
    u2             minor_version;//Class 的小版本号
    u2             major_version;//Class 的大版本号
```

紧接着魔数的四个字节存储的是Class文件的版本号：第5和第6位是**次版本号**，第7和第8位是**主版本号**。

#### 常量池（Constant Pool）

```c
    u2             constant_pool_count;//常量池的数量
    cp_info        constant_pool[constant_pool_count-1];//常量池
```

主次版本号之后的是常量池，常量池的数量是**constant_pool_count-1**，(**常量池计数器是从 1 开始计数的，将第 0 项常量空出来是有特殊考虑的，索引值为 0 代表“不引用任何一个常量池项**)

常量池主要存放两大常量：**字面量和符号引用**。
字面量：文本字符串、声明为 final 的常量值等
符号引用：
- 类和接口的全限定名
- 字段的名称和描述符
- 方法的名称和描述符

常量池中每一项常量都是一个表，表中项**开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型**

#### 访问标志(Access Flags)
```c
    u2             access_flags;//Class 的访问标记
```

在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。
![[images/Pasted image 20230327155739.png]]

#### 当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合
```Java
    u2             this_class;//当前类
    u2             super_class;//父类
    u2             interfaces_count;//接口
    u2             interfaces[interfaces_count];//一个类可以实现多个接口
```
类的继承关系由类索引、父类索引和接口索引集合三项确定。

类索引、父类索引和接口索引集合按照顺序排在访问标志之后，类索引用于确定这个**类的全限定名**，父类索引用于确定这个类的**父类的全限定名**，由于Java语言的单继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此**除了java.lang.Object外，所有Java类的父类索引都不为0。**

接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按implements(如果这个类本身是接口的话则是extends) 后的接口顺序从左到右排列在接口索引集合中。

#### 字段表集合（Fields）

```c
    u2             fields_count;//Class 文件的字段的个数
    field_info     fields[fields_count];//一个类会可以有个字段
```
字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但**不包括在方法内部声明的局部变量**。即**字段**

**field info(字段表) 的结构**:

![[images/Pasted image 20230327160115.png]]

- access_flags: 字段的作用域(public,private,protected修饰符)，是实例变量还是类变量(static修饰符),可否被序列化(transient修饰符),可变性(final),可见性(volatile 修饰符，是否强制从主内存读写)。
- name_index: 对常量池的引用，表示的字段的名称；
- descriptor_index: 对常量池的引用，表示字段和方法的描述符；
- attributes_count: 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；
- attributes\[attributes_count\]: 存放具体属性具体内容。

**字段的 access_flag 的取值**:
![[images/Pasted image 20230327160329.png]]

#### 方法表集合（Methods）
```c
    u2             methods_count;//Class 文件的方法的数量
    method_info    methods[methods_count];//一个类可以有个多个方法
```

methods_count 表示方法的数量，而 method_info 表示方法表。

方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。

**method_info(方法表的) 结构**:
![[images/Pasted image 20230327160519.png]]

**方法表的 access_flag 取值**：
![[images/Pasted image 20230327160614.png]]

> [!info] 注意
> 因为volatile修饰符和transient修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了**synchronized、native、abstract**等关键字修饰方法，所以也就多了这些关键字对应的标志。

#### 属性表集合（Attributes）

```c
   u2             attributes_count;//此类的属性表中的属性数
   attribute_info attributes[attributes_count];//属性表集合
```

Class文件中，字段表，方法表中都可以携带自己的属性表集合，以**用于描述某些场景专有的信息**。
属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。

## 类加载过程

### 类的生命周期
类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期包括7个阶段：加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)
![[images/Pasted image 20230328140702.png]]

### 类加载过程
**Class 文件需要加载到虚拟机中之后才能运行和使用**。

系统加载 Class 类型的文件主要三步：**加载->连接->初始化**。
连接过程又可分为三步：**验证->准备->解析**。

![[images/Pasted image 20230328140815.png]]

#### 加载
主要分为三步:
1. 通过全类名获取定义此类的二进制字节流。(可从多个地方获取)
2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构。
3. 在内存中生成一个代表该类的 Class 对象，作为方法区这些数据的访问入口。

加载这一步主要是通过我们后面要讲到的**类加载器**完成的。类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由**双亲委派模型**决定。

> [!info] 注意
> 每个Java类都有一个引用指向加载它的**ClassLoader**。不过，数组类不是通过 ClassLoader创建的，而是JVM在需要的时候自动创建的，数组类通过getClassLoader()方法获取ClassLoader的时候和该数组的元素类型的ClassLoader是一致的。

一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的loadClass()方法）。

加载阶段与连接阶段的部分动作(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。

#### 验证
验证是连接阶段的第一步，这一阶段的**目的是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求**，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。

防止恶意代码的执行，但验证阶段也不是必须要执行的阶段。
验证阶段主要由四个检验阶段组成：
1. 文件格式验证（Class文件格式检查）
2. 元数据验证（字节码语义检查）
3. 字节码验证（程序语义检查）
4. 符号引用验证（类的正确性检查）
![[images/Pasted image 20230328141708.png]]

**文件格式验证这一阶段是基于该类的二进制字节流进行的**，主要目的是**保证输入的字节流能正确地解析并存储于方法区之内**，格式上符合描述一个Java类型信息的要求。**其余三个验证阶段都是基于方法区的存储结构上进行的**，不会再直接读取、操作字节流了。

符号引用验证发生在类加载过程中的解析阶段，具体点说是 JVM 将符号引用转化为直接引用的时候（解析阶段会介绍符号引用和直接引用）。

符号引用验证的主要**目的是确保解析阶段能正常执行**，如果无法通过符号引用验证，JVM会抛出异常

#### 准备
**准备阶段是正式为类变量分配内存并设置类变量初始值的阶段**，这些内存都将在方法区中分配。

该阶段有以下几点需要注意：
1. 进行内存分配的仅包括类变量而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在Java堆中。
2. 类变量所使用的内存都应当在**方法区**中进行分配。不过有一点需要注意的是：JDK7之前，HotSpot使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。而在**JDK7及之后**，HotSpot已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，**这个时候类变量则会随着Class对象一起存放在Java堆中**。
3. 设置的初始值"通常情况"下是数据类型默认的零值。特殊情况：比如给value变量加上了final关键字public static final int value=111，那么准备阶段value的值就被赋值为111。

#### 解析
解析阶段是虚拟机**将常量池内的符号引用替换为直接引用的过程**。
解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。

![[images/Pasted image 20230328142448.png]]

解析阶段是虚拟机**将常量池内的符号引用替换为直接引用的过程**，也就是得到类或者字段、方法在内存中的指针或者偏移量。

#### 初始化
初始化阶段是**执行初始化方法 \<clinit\> ()方法的过程**，是类加载的最后一步，这一步 **JVM才开始真正执行类中定义的Java程序代码**(字节码)。

> [!info] 说明
> 说明\<clinit\>()方法是编译之后自动生成的。

对于\<clinit\>()方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 \<clinit\>()方法是**带锁线程安全**，所以在多线程环境下进行类初始化的话可能会引起多个线程阻塞，并且这种阻塞很难被发现。

对于初始化阶段，虚拟机严格规范了**有且只有5种情况下**，必须对类进行初始化:
1. 当遇到new、getstatic、putstatic或invokestatic这4条直接码指令时
	- 当jvm执行**new指令**时会初始化类。即当程序**创建一个类的实例对象**。
	- 当jvm执行**getstatic指令**时会初始化类。即程序**访问类的静态变量**(不是静态常量，常量会被加载到运行时常量池)。
	- 当jvm执行**putstatic指令**时会初始化类。即程序**给类的静态变量赋值**。
	- 当jvm执行**invokestatic指令**时会初始化类。即程序**调用类的静态方法**。
2. 使用java.lang.reflect包的方法对类进行反射调用时。如果类没初始化，需要触发其初始化。
3. 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。
4. 当虚拟机启动时，用户需要定义一个要执行的主类(包含main方法的那个类)，虚拟机会先初始化这个类。
5. MethodHandle和VarHandle可以看作是**轻量级的反射调用机制**，而要想使用这2个调用， 就必须先使用findStaticVarHandle来初始化要调用的类。
6. 当一个接口中定义了JDK8新加入的默认方法(被default关键字修饰的接口方法)时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

### 类卸载
**卸载类即该类的 Class 对象被 GC**。
卸载类需要满足 3 个要求：
- 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。
- 该类没有在其他任何地方被引用
- 该类的类加载器的实例已被 GC

在JVM生命周期内，由jvm自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。

## 类加载器

### 类加载过程
类加载过程：加载->连接->初始化。
连接过程又可分为三步：验证->准备->解析。
![[images/Pasted image 20230329143912.png]]

加载是类加载过程的第一步，主要做三件事：
- 通过**全类名**获取定义此类的**二进制字节流**
- 将字节流所代表的**静态存储结构转换为方法区的运行时数据结构**
- 在内存中**生成一个代表该类的Class对象**，作为方法区这些数据的访问入口

### 类加载器
它赋予了 Java 类可以被动态加载到 JVM 中并执行的能力。

- 类加载器是一个负责加载类的对象，用于实现类加载过程中的加载这一步。
- 每个 Java 类都有一个引用指向加载它的 ClassLoader。
- 数组类不是通过ClassLoader创建的（数组类没有对应的二进制字节流），是**由 JVM 直接生成的**。

类加载器的主要作用就是**加载Java类的字节码(.class 文件)到JVM中**(在内存中生成一个代表该类的Class对象)。

> 类加载器还可以加载 Java 应用所需的资源如文本、图像、配置文件、视频等等文件资源。

#### 类加载器加载规则
JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去**动态**加载。

对于已经加载的类会被放在ClassLoader中。在类加载的时候，系统会**首先判断当前类是否被加载过**。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类**只会被加载一次**。

#### 类加载器总结
JVM 中内置了三个重要的ClassLoader:
1. BootstrapClassLoader(启动类加载器)：最顶层的加载类，由C++实现，通常表示为 null，并且**没有父级**，主要用来**加载JDK内部的核心类库以及被-Xbootclasspath参数指定的路径下的所有类**。
2. ExtensionClassLoader(扩展类加载器)：主要负责**加载%JRE_HOME%/lib/ext目录下的jar包和类**以及被java.ext.dirs系统变量所指定的路径下的所有类
3. AppClassLoader(应用程序类加载器)：**面向我们用户的加载器**，负责**加载当前应用classpath下的所有jar包和类**。

> [!info] 注
> 除了这三种类加载器，用户还可以**加入自定义的类加载器**，以满足自己的特殊需求。比如可以对Java类的字节码(.class文件)进行加密，加载时再利用自定义的类加载器对其解密。

除了BootstrapClassLoader是JVM自身的一部分之外，其他所有的类加载器都是在JVM外部实现的，并且全都继承自ClassLoader抽象类

每个ClassLoader可以通过**getParent**()获取其父ClassLoader，如果获取到ClassLoader为null的话，那么**该类是通过BootstrapClassLoader加载**的

#### 自定义类加载器
自定义自己的类加载器，需要继承ClassLoader抽象类。

ClassLoader类有两个关键的方法：
1. protected Class loadClass(String name, boolean resolve)：**加载指定二进制名称的类，实现了双亲委派机制**。name为类的二进制名称，resove如果为true，在加载时调用resolveClass(Class\<?\> c)方法解析该类。
2. protected Class findClass(String name)：**根据类的二进制名称来查找类**，默认实现是空方法。

> [!info] 注
> 如果我们不想打破双亲委派模型，就重写ClassLoader类中的findClass()方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但如果想打破双亲委派模型则需要重写loadClass()方法。

### 双亲委派模型
类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载呢？这就需要提到双亲委派模型了。

- ClassLoader类使用**委托模型**来搜索类和资源。
- 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。
- ClassLoader实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。

> [!warning] 注
> 双亲委派模型**并不是一种强制性的约束**，只是JDK官方推荐的一种方式。如果我们因为某些特殊需求想要打破双亲委派模型，也是可以的，后文会介绍具体的方法。

**双亲委派模型**
![[images/Pasted image 20230329145259.png]]

类加载器之间的父子关系一般**不是以继承的关系来实现**的，而是通常**使用组合关系来复用父加载器的代码**

> [!info] 建议
> 在面向对象编程中，有一条非常经典的设计原则： **组合优于继承，多用组合少用继承。**

#### 双亲委派模型的执行流程

```c
protected Class<?> loadClass(String name, boolean resolve)
    throws ClassNotFoundException {
    synchronized (getClassLoadingLock(name)) {
        //首先，检查该类是否已经加载过
        Class c = findLoadedClass(name);
        if (c == null) {
            //如果 c 为 null，则说明该类没有被加载过
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    //当父类的加载器不为空，则通过父类的loadClass来加载该类
                    c = parent.loadClass(name, false);
                } else {
                    //当父类的加载器为空，则调用启动类加载器来加载该类
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                //非空父类的类加载器无法找到相应的类，则抛出异常
            }

            if (c == null) {
                //当父类加载器无法加载时，则调用findClass方法来加载该类
                //用户可通过覆写该方法，来自定义类加载器
                long t1 = System.nanoTime();
                c = findClass(name);

                //用于统计类加载器相关的信息
                sun.misc.PerfCounter.
                getParentDelegationTime().addTime(t1 - t0);
                
                sun.misc.PerfCounter.
                getFindClassTime().addElapsedTimeFrom(t1);
                
                sun.misc.PerfCounter.
                getFindClasses().increment();
            }
        }
        if (resolve) {
            //对类进行link操作
            resolveClass(c);
        }
        return c;
    }
}
```

每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。**在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载**。

双亲委派模型的执行流程：
1. 在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载.
2. 类加载器在进行类加载时，自己首先不会尝试加载这个类，而是把这个请求委派给父类加载器去完成；所有的请求最终都会传送到顶层的启动类加载器BootstrapClassLoader中。
3. 只有当父加载器反馈自己无法完成这个加载请求(它的搜索范围中没有找到所需的类)时，子加载器才会尝试自己去加载(调用自己的 findClass()方法来加载类)

> [!note] 注意
> JVM 判定两个Java类是否相同的具体规则：JVM**不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样**。只有两者都相同的情况，才认为两个类是相同的。

#### 双亲委派模型的好处
双亲委派模型保证了Java程序的稳定运行，可以**避免类的重复加载**，也保证了Java的核心API不被篡改。

#### 打破双亲委派模型方法

自定义加载器的话，需要继承ClassLoader。如果我们不想打破双亲委派模型，就重写 ClassLoader类中的findClass()方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，**如果想打破双亲委派模型则需要重写loadClass()方法**。

> [!note] 笔记
> 为什么是重写loadClass()方法打破双亲委派模型呢？
> 类加载器在进行类加载的时候，**它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成**（调用父加载器loadClass()方法来加载类）。


## 其他

### jvm中线程状态和操作系统中的有什么区别
jvm中线程状态有：
- New：线程刚被创建
- Runnable：调用了start()方法
- Blokced
- Waiting
- Timed_Waiting
- Terminated
![](images/Pasted%20image%2020230319190458.png)

OS中：
- 初始状态：线程新建的状态
- 可运行状态：也称为就绪状态，线程已经被创建，等待CPU调度器执行
- 运行状态：线程获得CPU时间片，运行中的状态
- 阻塞状态：等待一个条件，不会被分配CPU时间片
- 终止状态：线程执行完毕
![[images/Pasted image 20230407191447.png]]
### 为什么要自底向上检查是否被加载
如果之前加载过那就无需再加载了，每一级的类加载器都有自己的缓存，直接从缓存中取出使用；

### JVM的内存模型
虚拟机栈、本地方法栈、运行时堆、方法区、程序计数器
